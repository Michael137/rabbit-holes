```
template<typename _RealType, size_t __bits,
            typename _UniformRandomNumberGenerator>
     _RealType
     generate_canonical(_UniformRandomNumberGenerator& __urng)
     {
       static_assert(std::is_floating_point<_RealType>::value,
                     "template argument must be a floating point type");
 
       const size_t __b
         = std::min(static_cast<size_t>(std::numeric_limits<_RealType>::digits),
                    __bits);
       const long double __r = static_cast<long double>(__urng.max())
                             - static_cast<long double>(__urng.min()) + 1.0L;
       const size_t __log2r = std::log(__r) / std::log(2.0L);
       const size_t __m = std::max<size_t>(1UL,
                                           (__b + __log2r - 1UL) / __log2r);
       _RealType __ret;
       _RealType __sum = _RealType(0);
       _RealType __tmp = _RealType(1);
       for (size_t __k = __m; __k != 0; --__k)
         {
           __sum += _RealType(__urng() - __urng.min()) * __tmp;
           __tmp *= __r;
         }
       __ret = __sum / __tmp;
       if (__builtin_expect(__ret >= _RealType(1), 0))
         {
 #if _GLIBCXX_USE_C99_MATH_TR1
           __ret = std::nextafter(_RealType(1), _RealType(0));
 #else
           __ret = _RealType(1)
             - std::numeric_limits<_RealType>::epsilon() / _RealType(2);
 #endif
         }
       return __ret;
     }

/*
* An adaptor class for converting the output of any Generator into
* the input for a specific Distribution.
*/
template<typename _Engine, typename _DInputType>
 struct _Adaptor
 {
   static_assert(std::is_floating_point<_DInputType>::value,
                 "template argument must be a floating point type");

 public:
   _Adaptor(_Engine& __g)
   : _M_g(__g) { }

   _DInputType
   min() const
   { return _DInputType(0); }

   _DInputType
   max() const
   { return _DInputType(1); }

   /*
    * Converts a value generated by the adapted random number generator
    * into a value in the input domain for the dependent random number
    * distribution.
    */
   _DInputType
   operator()()
   {
     return std::generate_canonical<_DInputType,
                               std::numeric_limits<_DInputType>::digits,
                               _Engine>(_M_g);
   }

 private:
   _Engine& _M_g;
 };

/**
    * @brief Uniform continuous distribution for random numbers.
    *
    * A continuous random distribution on the range [min, max) with equal
    * probability throughout the range.  The URNG should be real-valued and
    * deliver number in the range [0, 1).
    */
   template<typename _RealType = double>
     class uniform_real_distribution
     {
       static_assert(std::is_floating_point<_RealType>::value,
                     "result_type must be a floating point type");
 
     public:
       /** The type of the range of the distribution. */
       typedef _RealType result_type;
 
       /** Parameter type. */
       struct param_type
       {
         typedef uniform_real_distribution<_RealType> distribution_type;
 
         explicit
         param_type(_RealType __a = _RealType(0),
                    _RealType __b = _RealType(1))
         : _M_a(__a), _M_b(__b)
         {
           __glibcxx_assert(_M_a <= _M_b);
         }
 
         result_type
         a() const
         { return _M_a; }
 
         result_type
         b() const
         { return _M_b; }
 
         friend bool
         operator==(const param_type& __p1, const param_type& __p2)
         { return __p1._M_a == __p2._M_a && __p1._M_b == __p2._M_b; }
 
         friend bool
         operator!=(const param_type& __p1, const param_type& __p2)
         { return !(__p1 == __p2); }
 
       private:
         _RealType _M_a;
         _RealType _M_b;
       };
 
     public:
       /**
        * @brief Constructs a uniform_real_distribution object.
        *
        * @param __a [IN]  The lower bound of the distribution.
        * @param __b [IN]  The upper bound of the distribution.
        */
       explicit
       uniform_real_distribution(_RealType __a = _RealType(0),
                                 _RealType __b = _RealType(1))
       : _M_param(__a, __b)
       { }
 
       explicit
       uniform_real_distribution(const param_type& __p)
       : _M_param(__p)
       { }
 
       /**
        * @brief Resets the distribution state.
        *
        * Does nothing for the uniform real distribution.
        */
       void
       reset() { }
 
       result_type
       a() const
       { return _M_param.a(); }
 
       result_type
       b() const
       { return _M_param.b(); }
 
       /**
        * @brief Returns the parameter set of the distribution.
        */
       param_type
       param() const
       { return _M_param; }
 
       /**
        * @brief Sets the parameter set of the distribution.
        * @param __param The new parameter set of the distribution.
        */
       void
       param(const param_type& __param)
       { _M_param = __param; }
 
       /**
        * @brief Returns the inclusive lower bound of the distribution range.
        */
       result_type
       min() const
       { return this->a(); }
 
       /**
        * @brief Returns the inclusive upper bound of the distribution range.
        */
       result_type
       max() const
       { return this->b(); }
 
       /**
        * @brief Generating functions.
        */
       template<typename _UniformRandomNumberGenerator>
         result_type
         operator()(_UniformRandomNumberGenerator& __urng)
         { return this->operator()(__urng, _M_param); }
 
       template<typename _UniformRandomNumberGenerator>
         result_type
         operator()(_UniformRandomNumberGenerator& __urng,
                    const param_type& __p)
         {
           __detail::_Adaptor<_UniformRandomNumberGenerator, result_type>
             __aurng(__urng);
           return (__aurng() * (__p.b() - __p.a())) + __p.a();
         }
 
       template<typename _ForwardIterator,
                typename _UniformRandomNumberGenerator>
         void
         __generate(_ForwardIterator __f, _ForwardIterator __t,
                    _UniformRandomNumberGenerator& __urng)
         { this->__generate(__f, __t, __urng, _M_param); }
 
       template<typename _ForwardIterator,
                typename _UniformRandomNumberGenerator>
         void
         __generate(_ForwardIterator __f, _ForwardIterator __t,
                    _UniformRandomNumberGenerator& __urng,
                    const param_type& __p)
         { this->__generate_impl(__f, __t, __urng, __p); }
 
       template<typename _UniformRandomNumberGenerator>
         void
         __generate(result_type* __f, result_type* __t,
                    _UniformRandomNumberGenerator& __urng,
                    const param_type& __p)
         { this->__generate_impl(__f, __t, __urng, __p); }
 
       /**
        * @brief Return true if two uniform real distributions have
        *        the same parameters.
        */
       friend bool
       operator==(const uniform_real_distribution& __d1,
                  const uniform_real_distribution& __d2)
       { return __d1._M_param == __d2._M_param; }
 
     private:
       template<typename _ForwardIterator,
                typename _UniformRandomNumberGenerator>
         void
         __generate_impl(_ForwardIterator __f, _ForwardIterator __t,
                         _UniformRandomNumberGenerator& __urng,
                         const param_type& __p);
 
       param_type _M_param;
     };
 
   /**
    * @brief Return true if two uniform real distributions have
    *        different parameters.
    */
   template<typename _IntType>
     inline bool
     operator!=(const std::uniform_real_distribution<_IntType>& __d1,
                const std::uniform_real_distribution<_IntType>& __d2)
     { return !(__d1 == __d2); }

/**
    * A generalized feedback shift register discrete random number generator.
    *
    * This algorithm avoids multiplication and division and is designed to be
    * friendly to a pipelined architecture.  If the parameters are chosen
    * correctly, this generator will produce numbers with a very long period and
    * fairly good apparent entropy, although still not cryptographically strong.
    *
    * The best way to use this generator is with the predefined mt19937 class.
    *
    * This algorithm was originally invented by Makoto Matsumoto and
    * Takuji Nishimura.
    *
    * @tparam __w  Word size, the number of bits in each element of 
    *              the state vector.
    * @tparam __n  The degree of recursion.
    * @tparam __m  The period parameter.
    * @tparam __r  The separation point bit index.
    * @tparam __a  The last row of the twist matrix.
    * @tparam __u  The first right-shift tempering matrix parameter.
    * @tparam __d  The first right-shift tempering matrix mask.
    * @tparam __s  The first left-shift tempering matrix parameter.
    * @tparam __b  The first left-shift tempering matrix mask.
    * @tparam __t  The second left-shift tempering matrix parameter.
    * @tparam __c  The second left-shift tempering matrix mask.
    * @tparam __l  The second right-shift tempering matrix parameter.
    * @tparam __f  Initialization multiplier.
    */
   template<typename _UIntType, size_t __w,
            size_t __n, size_t __m, size_t __r,
            _UIntType __a, size_t __u, _UIntType __d, size_t __s,
            _UIntType __b, size_t __t,
            _UIntType __c, size_t __l, _UIntType __f>
     class mersenne_twister_engine
     {
       static_assert(std::is_unsigned<_UIntType>::value,
                     "result_type must be an unsigned integral type");
       static_assert(1u <= __m && __m <= __n,
                     "template argument substituting __m out of bounds");
       static_assert(__r <= __w, "template argument substituting "
                     "__r out of bound");
       static_assert(__u <= __w, "template argument substituting "
                     "__u out of bound");
       static_assert(__s <= __w, "template argument substituting "
                     "__s out of bound");
       static_assert(__t <= __w, "template argument substituting "
                     "__t out of bound");
       static_assert(__l <= __w, "template argument substituting "
                     "__l out of bound");
       static_assert(__w <= std::numeric_limits<_UIntType>::digits,
                     "template argument substituting __w out of bound");
       static_assert(__a <= (__detail::_Shift<_UIntType, __w>::__value - 1),
                     "template argument substituting __a out of bound");
       static_assert(__b <= (__detail::_Shift<_UIntType, __w>::__value - 1),
                     "template argument substituting __b out of bound");
       static_assert(__c <= (__detail::_Shift<_UIntType, __w>::__value - 1),
                     "template argument substituting __c out of bound");
       static_assert(__d <= (__detail::_Shift<_UIntType, __w>::__value - 1),
                     "template argument substituting __d out of bound");
       static_assert(__f <= (__detail::_Shift<_UIntType, __w>::__value - 1),
                     "template argument substituting __f out of bound");
 
     public:
       /** The type of the generated random value. */
       typedef _UIntType result_type;
 
       // parameter values
       static constexpr size_t      word_size                 = __w;
       static constexpr size_t      state_size                = __n;
       static constexpr size_t      shift_size                = __m;
       static constexpr size_t      mask_bits                 = __r;
       static constexpr result_type xor_mask                  = __a;
       static constexpr size_t      tempering_u               = __u;
       static constexpr result_type tempering_d               = __d;
       static constexpr size_t      tempering_s               = __s;
       static constexpr result_type tempering_b               = __b;
       static constexpr size_t      tempering_t               = __t;
       static constexpr result_type tempering_c               = __c;
       static constexpr size_t      tempering_l               = __l;
       static constexpr result_type initialization_multiplier = __f;
       static constexpr result_type default_seed = 5489u;
 
       // constructors and member function
       explicit
       mersenne_twister_engine(result_type __sd = default_seed)
       { seed(__sd); }
 
       /**
        * @brief Constructs a %mersenne_twister_engine random number generator
        *        engine seeded from the seed sequence @p __q.
        *
        * @param __q the seed sequence.
        */
       template<typename _Sseq, typename = typename
         std::enable_if<!std::is_same<_Sseq, mersenne_twister_engine>::value>
                ::type>
         explicit
         mersenne_twister_engine(_Sseq& __q)
         { seed(__q); }
 
       void
       seed(result_type __sd = default_seed);
 
       template<typename _Sseq>
         typename std::enable_if<std::is_class<_Sseq>::value>::type
         seed(_Sseq& __q);
 
       /**
        * @brief Gets the smallest possible value in the output range.
        */
       static constexpr result_type
       min()
       { return 0; };
 
       /**
        * @brief Gets the largest possible value in the output range.
        */
       static constexpr result_type
       max()
       { return __detail::_Shift<_UIntType, __w>::__value - 1; }
 
       /**
        * @brief Discard a sequence of random numbers.
        */
       void
       discard(unsigned long long __z);
 
       result_type
       operator()();
 
       /**
        * @brief Compares two % mersenne_twister_engine random number generator
        *        objects of the same type for equality.
        *
        * @param __lhs A % mersenne_twister_engine random number generator
        *              object.
        * @param __rhs Another % mersenne_twister_engine random number
        *              generator object.
        *
        * @returns true if the infinite sequences of generated values
        *          would be equal, false otherwise.
        */
       friend bool
       operator==(const mersenne_twister_engine& __lhs,
                  const mersenne_twister_engine& __rhs)
       { return (std::equal(__lhs._M_x, __lhs._M_x + state_size, __rhs._M_x)
                 && __lhs._M_p == __rhs._M_p); }
 
       /**
        * @brief Inserts the current state of a % mersenne_twister_engine
        *        random number generator engine @p __x into the output stream
        *        @p __os.
        *
        * @param __os An output stream.
        * @param __x  A % mersenne_twister_engine random number generator
        *             engine.
        *
        * @returns The output stream with the state of @p __x inserted or in
        * an error state.
        */
       template<typename _UIntType1,
                size_t __w1, size_t __n1,
                size_t __m1, size_t __r1,
                _UIntType1 __a1, size_t __u1,
                _UIntType1 __d1, size_t __s1,
                _UIntType1 __b1, size_t __t1,
                _UIntType1 __c1, size_t __l1, _UIntType1 __f1,
                typename _CharT, typename _Traits>
         friend std::basic_ostream<_CharT, _Traits>&
         operator<<(std::basic_ostream<_CharT, _Traits>& __os,
                    const std::mersenne_twister_engine<_UIntType1, __w1, __n1,
                    __m1, __r1, __a1, __u1, __d1, __s1, __b1, __t1, __c1,
                    __l1, __f1>& __x);
 
       /**
        * @brief Extracts the current state of a % mersenne_twister_engine
        *        random number generator engine @p __x from the input stream
        *        @p __is.
        *
        * @param __is An input stream.
        * @param __x  A % mersenne_twister_engine random number generator
        *             engine.
        *
        * @returns The input stream with the state of @p __x extracted or in
        * an error state.
        */
       template<typename _UIntType1,
                size_t __w1, size_t __n1,
                size_t __m1, size_t __r1,
                _UIntType1 __a1, size_t __u1,
                _UIntType1 __d1, size_t __s1,
                _UIntType1 __b1, size_t __t1,
                _UIntType1 __c1, size_t __l1, _UIntType1 __f1,
                typename _CharT, typename _Traits>
         friend std::basic_istream<_CharT, _Traits>&
         operator>>(std::basic_istream<_CharT, _Traits>& __is,
                    std::mersenne_twister_engine<_UIntType1, __w1, __n1, __m1,
                    __r1, __a1, __u1, __d1, __s1, __b1, __t1, __c1,
                    __l1, __f1>& __x);
 
     private:
       void _M_gen_rand();
 
       _UIntType _M_x[state_size];
       size_t    _M_p;
     };
 
   /**
    * @brief Compares two % mersenne_twister_engine random number generator
    *        objects of the same type for inequality.
    *
    * @param __lhs A % mersenne_twister_engine random number generator
    *              object.
    * @param __rhs Another % mersenne_twister_engine random number
    *              generator object.
    *
    * @returns true if the infinite sequences of generated values
    *          would be different, false otherwise.
    */
   template<typename _UIntType, size_t __w,
            size_t __n, size_t __m, size_t __r,
            _UIntType __a, size_t __u, _UIntType __d, size_t __s,
            _UIntType __b, size_t __t,
            _UIntType __c, size_t __l, _UIntType __f>
     inline bool
     operator!=(const std::mersenne_twister_engine<_UIntType, __w, __n, __m,
                __r, __a, __u, __d, __s, __b, __t, __c, __l, __f>& __lhs,
                const std::mersenne_twister_engine<_UIntType, __w, __n, __m,
                __r, __a, __u, __d, __s, __b, __t, __c, __l, __f>& __rhs)
     { return !(__lhs == __rhs); }/**
    * A generalized feedback shift register discrete random number generator.
    *
    * This algorithm avoids multiplication and division and is designed to be
    * friendly to a pipelined architecture.  If the parameters are chosen
    * correctly, this generator will produce numbers with a very long period and
    * fairly good apparent entropy, although still not cryptographically strong.
    *
    * The best way to use this generator is with the predefined mt19937 class.
    *
    * This algorithm was originally invented by Makoto Matsumoto and
    * Takuji Nishimura.
    *
    * @tparam __w  Word size, the number of bits in each element of 
    *              the state vector.
    * @tparam __n  The degree of recursion.
    * @tparam __m  The period parameter.
    * @tparam __r  The separation point bit index.
    * @tparam __a  The last row of the twist matrix.
    * @tparam __u  The first right-shift tempering matrix parameter.
    * @tparam __d  The first right-shift tempering matrix mask.
    * @tparam __s  The first left-shift tempering matrix parameter.
    * @tparam __b  The first left-shift tempering matrix mask.
    * @tparam __t  The second left-shift tempering matrix parameter.
    * @tparam __c  The second left-shift tempering matrix mask.
    * @tparam __l  The second right-shift tempering matrix parameter.
    * @tparam __f  Initialization multiplier.
    */
   template<typename _UIntType, size_t __w,
            size_t __n, size_t __m, size_t __r,
            _UIntType __a, size_t __u, _UIntType __d, size_t __s,
            _UIntType __b, size_t __t,
            _UIntType __c, size_t __l, _UIntType __f>
     class mersenne_twister_engine
     {
       static_assert(std::is_unsigned<_UIntType>::value,
                     "result_type must be an unsigned integral type");
       static_assert(1u <= __m && __m <= __n,
                     "template argument substituting __m out of bounds");
       static_assert(__r <= __w, "template argument substituting "
                     "__r out of bound");
       static_assert(__u <= __w, "template argument substituting "
                     "__u out of bound");
       static_assert(__s <= __w, "template argument substituting "
                     "__s out of bound");
       static_assert(__t <= __w, "template argument substituting "
                     "__t out of bound");
       static_assert(__l <= __w, "template argument substituting "
                     "__l out of bound");
       static_assert(__w <= std::numeric_limits<_UIntType>::digits,
                     "template argument substituting __w out of bound");
       static_assert(__a <= (__detail::_Shift<_UIntType, __w>::__value - 1),
                     "template argument substituting __a out of bound");
       static_assert(__b <= (__detail::_Shift<_UIntType, __w>::__value - 1),
                     "template argument substituting __b out of bound");
       static_assert(__c <= (__detail::_Shift<_UIntType, __w>::__value - 1),
                     "template argument substituting __c out of bound");
       static_assert(__d <= (__detail::_Shift<_UIntType, __w>::__value - 1),
                     "template argument substituting __d out of bound");
       static_assert(__f <= (__detail::_Shift<_UIntType, __w>::__value - 1),
                     "template argument substituting __f out of bound");
 
     public:
       /** The type of the generated random value. */
       typedef _UIntType result_type;
 
       // parameter values
       static constexpr size_t      word_size                 = __w;
       static constexpr size_t      state_size                = __n;
       static constexpr size_t      shift_size                = __m;
       static constexpr size_t      mask_bits                 = __r;
       static constexpr result_type xor_mask                  = __a;
       static constexpr size_t      tempering_u               = __u;
       static constexpr result_type tempering_d               = __d;
       static constexpr size_t      tempering_s               = __s;
       static constexpr result_type tempering_b               = __b;
       static constexpr size_t      tempering_t               = __t;
       static constexpr result_type tempering_c               = __c;
       static constexpr size_t      tempering_l               = __l;
       static constexpr result_type initialization_multiplier = __f;
       static constexpr result_type default_seed = 5489u;
 
       // constructors and member function
       explicit
       mersenne_twister_engine(result_type __sd = default_seed)
       { seed(__sd); }
 
       /**
        * @brief Constructs a %mersenne_twister_engine random number generator
        *        engine seeded from the seed sequence @p __q.
        *
        * @param __q the seed sequence.
        */
       template<typename _Sseq, typename = typename
         std::enable_if<!std::is_same<_Sseq, mersenne_twister_engine>::value>
                ::type>
         explicit
         mersenne_twister_engine(_Sseq& __q)
         { seed(__q); }
 
       void
       seed(result_type __sd = default_seed);
 
       template<typename _Sseq>
         typename std::enable_if<std::is_class<_Sseq>::value>::type
         seed(_Sseq& __q);
 
       /**
        * @brief Gets the smallest possible value in the output range.
        */
       static constexpr result_type
       min()
       { return 0; };
 
       /**
        * @brief Gets the largest possible value in the output range.
        */
       static constexpr result_type
       max()
       { return __detail::_Shift<_UIntType, __w>::__value - 1; }
 
       /**
        * @brief Discard a sequence of random numbers.
        */
       void
       discard(unsigned long long __z);
 
       result_type
       operator()();
 
       /**
        * @brief Compares two % mersenne_twister_engine random number generator
        *        objects of the same type for equality.
        *
        * @param __lhs A % mersenne_twister_engine random number generator
        *              object.
        * @param __rhs Another % mersenne_twister_engine random number
        *              generator object.
        *
        * @returns true if the infinite sequences of generated values
        *          would be equal, false otherwise.
        */
       friend bool
       operator==(const mersenne_twister_engine& __lhs,
                  const mersenne_twister_engine& __rhs)
       { return (std::equal(__lhs._M_x, __lhs._M_x + state_size, __rhs._M_x)
                 && __lhs._M_p == __rhs._M_p); }
 
       /**
        * @brief Inserts the current state of a % mersenne_twister_engine
        *        random number generator engine @p __x into the output stream
        *        @p __os.
        *
        * @param __os An output stream.
        * @param __x  A % mersenne_twister_engine random number generator
        *             engine.
        *
        * @returns The output stream with the state of @p __x inserted or in
        * an error state.
        */
       template<typename _UIntType1,
                size_t __w1, size_t __n1,
                size_t __m1, size_t __r1,
                _UIntType1 __a1, size_t __u1,
                _UIntType1 __d1, size_t __s1,
                _UIntType1 __b1, size_t __t1,
                _UIntType1 __c1, size_t __l1, _UIntType1 __f1,
                typename _CharT, typename _Traits>
         friend std::basic_ostream<_CharT, _Traits>&
         operator<<(std::basic_ostream<_CharT, _Traits>& __os,
                    const std::mersenne_twister_engine<_UIntType1, __w1, __n1,
                    __m1, __r1, __a1, __u1, __d1, __s1, __b1, __t1, __c1,
                    __l1, __f1>& __x);
 
       /**
        * @brief Extracts the current state of a % mersenne_twister_engine
        *        random number generator engine @p __x from the input stream
        *        @p __is.
        *
        * @param __is An input stream.
        * @param __x  A % mersenne_twister_engine random number generator
        *             engine.
        *
        * @returns The input stream with the state of @p __x extracted or in
        * an error state.
        */
       template<typename _UIntType1,
                size_t __w1, size_t __n1,
                size_t __m1, size_t __r1,
                _UIntType1 __a1, size_t __u1,
                _UIntType1 __d1, size_t __s1,
                _UIntType1 __b1, size_t __t1,
                _UIntType1 __c1, size_t __l1, _UIntType1 __f1,
                typename _CharT, typename _Traits>
         friend std::basic_istream<_CharT, _Traits>&
         operator>>(std::basic_istream<_CharT, _Traits>& __is,
                    std::mersenne_twister_engine<_UIntType1, __w1, __n1, __m1,
                    __r1, __a1, __u1, __d1, __s1, __b1, __t1, __c1,
                    __l1, __f1>& __x);
 
     private:
       void _M_gen_rand();
 
       _UIntType _M_x[state_size];
       size_t    _M_p;
     };
 
   /**
    * @brief Compares two % mersenne_twister_engine random number generator
    *        objects of the same type for inequality.
    *
    * @param __lhs A % mersenne_twister_engine random number generator
    *              object.
    * @param __rhs Another % mersenne_twister_engine random number
    *              generator object.
    *
    * @returns true if the infinite sequences of generated values
    *          would be different, false otherwise.
    */
   template<typename _UIntType, size_t __w,
            size_t __n, size_t __m, size_t __r,
            _UIntType __a, size_t __u, _UIntType __d, size_t __s,
            _UIntType __b, size_t __t,
            _UIntType __c, size_t __l, _UIntType __f>
     inline bool
     operator!=(const std::mersenne_twister_engine<_UIntType, __w, __n, __m,
                __r, __a, __u, __d, __s, __b, __t, __c, __l, __f>& __lhs,
                const std::mersenne_twister_engine<_UIntType, __w, __n, __m,
                __r, __a, __u, __d, __s, __b, __t, __c, __l, __f>& __rhs)
     { return !(__lhs == __rhs); }

 
   template<typename _UIntType, size_t __w,
            size_t __n, size_t __m, size_t __r,
            _UIntType __a, size_t __u, _UIntType __d, size_t __s,
            _UIntType __b, size_t __t, _UIntType __c, size_t __l,
            _UIntType __f>
     void
     mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d,
                             __s, __b, __t, __c, __l, __f>::
     _M_gen_rand(void)
     {
       const _UIntType __upper_mask = (~_UIntType()) << __r;
       const _UIntType __lower_mask = ~__upper_mask;
 
       for (size_t __k = 0; __k < (__n - __m); ++__k)
         {
           _UIntType __y = ((_M_x[__k] & __upper_mask)
                            | (_M_x[__k + 1] & __lower_mask));
           _M_x[__k] = (_M_x[__k + __m] ^ (__y >> 1)
                        ^ ((__y & 0x01) ? __a : 0));
         }
 
       for (size_t __k = (__n - __m); __k < (__n - 1); ++__k)
         {
           _UIntType __y = ((_M_x[__k] & __upper_mask)
                            | (_M_x[__k + 1] & __lower_mask));
           _M_x[__k] = (_M_x[__k + (__m - __n)] ^ (__y >> 1)
                        ^ ((__y & 0x01) ? __a : 0));
         }
 
       _UIntType __y = ((_M_x[__n - 1] & __upper_mask)
                        | (_M_x[0] & __lower_mask));
       _M_x[__n - 1] = (_M_x[__m - 1] ^ (__y >> 1)
                        ^ ((__y & 0x01) ? __a : 0));
       _M_p = 0;
     }
 
   template<typename _UIntType, size_t __w,
            size_t __n, size_t __m, size_t __r,
            _UIntType __a, size_t __u, _UIntType __d, size_t __s,
            _UIntType __b, size_t __t, _UIntType __c, size_t __l,
            _UIntType __f>
     typename
     mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d,
                             __s, __b, __t, __c, __l, __f>::result_type
     mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d,
                             __s, __b, __t, __c, __l, __f>::
     operator()()
     {
       // Reload the vector - cost is O(n) amortized over n calls.
       if (_M_p >= state_size)
         _M_gen_rand();
 
       // Calculate o(x(i)).
       result_type __z = _M_x[_M_p++];
       __z ^= (__z >> __u) & __d;
       __z ^= (__z << __s) & __b;
       __z ^= (__z << __t) & __c;
       __z ^= (__z >> __l);
 
       return __z;
     }
```
